<!DOCTYPE html>
<!-- VERSION: 2025-01-06-DEBUG -->
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>å³æ™‚ä¸‹æ³¨ç›£æ§ç³»çµ± v3.1 - èª¿è©¦ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            background: #000;
            color: #0f0;
            font-size: 14px;
            line-height: 1.2;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: calc(100vh - 40px);
        }

        .header {
            border: 1px solid #333;
            padding: 15px;
            margin-bottom: 20px;
            background: #111;
        }

        .round-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .round-number {
            font-size: 18px;
            font-weight: bold;
            color: #ff0;
        }

        .lock-time {
            color: #f80;
            cursor: pointer;
        }

        .lock-time:hover {
            opacity: 0.8;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            text-align: center;
        }

        .stat-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }

        .stat-value.up {
            color: #77dd77;
        }

        .stat-value.down {
            color: #ff6666;
        }

        .bets-container {
            border: 1px solid #333;
            background: #111;
            height: 600px;
            overflow: auto;
            font-size: 12px;
            transition: opacity 0.3s ease-in-out;
        }

        .bets-header {
            background: #222;
            padding: 10px;
            border-bottom: 1px solid #333;
            display: grid;
            grid-template-columns: 60px 50px minmax(360px, 1fr) 56px 80px minmax(420px, 2fr);
            gap: 8px;
            font-weight: bold;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .bets-header > div {
            text-align: center;
        }

        .bets-header > div:nth-child(3) {
            text-align: left;
        }

        .bet-item {
            border-bottom: 1px solid #333;
            background: #111;
            padding: 8px 10px;
            display: grid;
            grid-template-columns: 60px 50px minmax(360px, 1fr) 56px 80px minmax(420px, 2fr);
            gap: 8px;
            align-items: center;
            height: 65px;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }

        .bet-item:nth-child(even) {
            background: #0a0a0a;
        }

        /* æ–°ä¸‹æ³¨é …ç›®æ·¡å…¥å‹•ç•« */
        .bet-item.fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* æ•¸æ“šæ›´æ–°æ™‚çš„å¹³æ»‘éæ¸¡ */
        .stat-value {
            transition: all 0.3s ease-in-out;
        }

        .stat-value.updating {
            opacity: 0.5;
        }

        /* æœ‰å¾—åˆ†æ•¸æ“šèˆ‡ç„¡æ•¸æ“šçš„åˆ†éš”ç·š */
        .score-separator {
            height: 3px;
            background: linear-gradient(90deg,
                transparent 0%,
                #FFD700 10%,
                #FFD700 90%,
                transparent 100%);
            margin: 5px 0;
            position: relative;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        .score-separator::before {
            content: 'â–¼ ä»¥ä¸‹ç„¡å¾—åˆ†æ•¸æ“š â–¼';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            padding: 2px 15px;
            color: #FFD700;
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
        }

        .bet-time {
            color: #888;
            text-align: center;
        }

        .bet-epoch {
            color: #ff0;
            text-align: center;
        }

        .bet-wallet {
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-family: inherit;
            color: #888;
            word-break: break-all;
            font-size: 12px;
            line-height: 1.1;
            cursor: pointer;
        }

        .bet-item.hl-1 { outline: 2px solid #00f0a8; box-shadow: inset 0 0 8px rgba(0,240,168,0.4); }
        .bet-item.hl-2 { outline: 2px solid #b0003a; box-shadow: inset 0 0 8px rgba(176,0,58,0.35); }
        .bet-item.hl-3 { outline: 2px solid #ffae00; box-shadow: inset 0 0 8px rgba(255,174,0,0.35); }
        .bet-item.hl-4 { outline: 2px solid #8a2be2; box-shadow: inset 0 0 8px rgba(138,43,226,0.4); }
        .bet-item.hl-5 { outline: 2px solid #1e90ff; box-shadow: inset 0 0 8px rgba(30,144,255,0.4); }
        .bet-item.hl-6 { outline: 2px solid #ff69b4; box-shadow: inset 0 0 8px rgba(255,105,180,0.4); }
        .bet-item.hl-1, .bet-item.hl-2, .bet-item.hl-3, .bet-item.hl-4, .bet-item.hl-5, .bet-item.hl-6 { border-radius: 4px; }

        .bet-wallet.multi-claim-below-5 {
            color: #0af !important;
            font-weight: bold !important;
        }

        .bet-wallet.multi-claim-above-5 {
            color: #9370db !important;
            font-weight: bold !important;
        }

        .bet-direction {
            font-weight: bold;
            text-align: center;
        }

        .bet-direction.up {
            color: #77dd77;
        }

        .bet-direction.down {
            color: #ff6666;
        }

        .bet-amount {
            text-align: center;
            color: #ff0;
        }

        .bet-amount.small {
            color: #888;
            font-weight: normal;
        }

        .bet-amount.medium {
            color: #ff0;
            font-weight: normal;
        }

        .bet-amount.large {
            color: #ffa500;
            font-weight: normal;
        }

        .bet-amount.huge {
            color: #f00;
            font-weight: bold;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: #0a0;
            color: #000;
        }

        .connection-status.disconnected {
            background: #a00;
            color: #fff;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }

        .epoch-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .nav-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: #555;
        }
        
        .nav-btn:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
        }
        
        .epoch-display {
            text-align: center;
        }

        .bet-item.new-bet {
            animation: slideIn 0.5s ease-out;
            border-left: 4px solid #FFD700;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .wallet-analysis {
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .wallet-analysis .chart-box {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .wallet-analysis svg {
            display: block;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
            position: static;
        }

        /* å›æ¸¬è¡¨æ ¼æ¨£å¼ */
        .backtest-section {
            margin-bottom: 20px;
            border: 1px solid #333;
            background: #111;
            padding: 15px;
        }

        .backtest-header {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }

        .backtest-table-container {
            overflow-x: auto;
            overflow-y: hidden;
        }

        .backtest-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 1px;
            font-size: 11px;
            background: #000;
        }

        .backtest-table td {
            padding: 6px 4px;
            text-align: center;
            background: #1a1a1a;
            height: 32px;
            vertical-align: middle;
        }

        /* ç¬¬ä¸€åˆ—ï¼šç­–ç•¥åç¨± */
        .backtest-table td.strategy-name {
            width: 140px;
            font-weight: bold;
            text-align: left;
            padding-left: 10px;
            color: #aaa;
            white-space: nowrap;
        }

        /* ç¬¬äºŒåˆ—ï¼šå‹ç‡ */
        .backtest-table td.strategy-winrate {
            width: 90px;
            font-weight: bold;
            font-size: 13px;
        }

        /* å±€æ¬¡çµæœåˆ— */
        .backtest-table td.epoch-result {
            width: 24px;
            min-width: 24px;
            padding: 4px 2px;
            transition: background-color 0.3s ease;
        }

        /* å‹ç‡é¡è‰² */
        .winrate-high { color: #00FF00; }
        .winrate-medium { color: #FFFF00; }
        .winrate-low { color: #FF6666; }

        /* é æ¸¬åœ“åœˆ */
        .prediction-circle {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .prediction-up {
            background: #4CAF50;
        }

        .prediction-down {
            background: #F44336;
        }

        .prediction-none {
            background: transparent;
            border: 1px solid #333;
        }

        /* çµæœèƒŒæ™¯è‰² */
        .result-bg-up {
            background: #2d5a2d !important;
        }

        .result-bg-down {
            background: #5a2d2d !important;
        }

        /* ç„¡æ•¸æ“š */
        .no-prediction {
            color: #444;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="round-info">
                <div class="epoch-nav">
                    <button class="nav-btn" id="prevEpoch">â† ä¸Šä¸€å±€</button>
                    <div class="epoch-display">
                        <div class="round-number">å±€æ¬¡ï¼š <span id="currentRound">--</span></div>
                        <div style="color: #888; font-size: 12px;" id="epochMode">å³æ™‚æ¨¡å¼</div>
                    </div>
                    <button class="nav-btn" id="nextEpoch">ä¸‹ä¸€å±€ â†’</button>
                </div>

                <!-- æ™ºèƒ½é æ¸¬ç³»çµ± -->
                <div style="display: flex; flex-direction: column; gap: 8px; background: #1a1a1a; padding: 10px; border-radius: 6px; border: 1px solid #333;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <!-- ä¸»è¦é æ¸¬ -->
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="color: #FFD700; font-size: 16px; font-weight: bold;">ğŸ”® AIé æ¸¬</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="color: #aaa; font-size: 14px;">å‹•é‡ç­–ç•¥:</span>
                                <span id="momentumPrediction" style="color: #888; font-size: 18px; font-weight: bold;">--</span>
                            </div>
                            <div id="predictionConfidence" style="font-size: 12px; color: #666; background: #2a2a2a; padding: 2px 6px; border-radius: 3px;">--</div>
                        </div>
                        
                        <!-- ç­–ç•¥æ•ˆèƒ½ -->
                        <div style="display: flex; gap: 12px; font-size: 12px;">
                            <div title="å‹•é‡ç­–ç•¥æ­·å²å‹ç‡">
                                <span style="color: #aaa;">å‹•é‡:</span>
                                <span id="momentumRate" style="color: #0f0; font-weight: bold;">--</span>
                            </div>
                            <div title="è·Ÿéš¨æœ€é«˜å‹ç‡ç­–ç•¥">
                                <span style="color: #aaa;">è·Ÿéš¨:</span>
                                <span id="followBestRate" style="color: #888; font-weight: bold;">--</span>
                            </div>
                            <div title="åå‘æœ€ä½å‹ç‡ç­–ç•¥">
                                <span style="color: #aaa;">åå‘:</span>
                                <span id="reverseLowRate" style="color: #888; font-weight: bold;">--</span>
                            </div>
                        </div>
                    </div>

                    <!-- é æ¸¬ç†ç”± -->
                    <div id="momentumReasons" style="font-size: 12px; color: #aaa; display: none;">
                        ç†ç”±ï¼š<span id="momentumReasonsText">--</span>
                    </div>

                    <!-- äº¤æ˜“å»¶é²å¡ç‰‡ -->
                    <div id="txBenchmark" style="display: flex; gap: 12px; font-size: 12px; color: #888;">
                        <div style="color: #9CDCFE;">â± äº¤æ˜“å»¶é²</div>
                        <div>P50: <span id="txP50">--</span> ms</div>
                        <div>P90: <span id="txP90">--</span> ms</div>
                        <div>å»ºè­° Î´: <span id="txDelta">--</span> s</div>
                    </div>
                </div>

                <div class="lock-time">
                    é–å®šå€’æ•¸ï¼š <span id="lockCountdown">--</span>
                    <div style="font-size: 12px; color: #4CAF50; margin-top: 2px;" id="connectionInfo">æ­£åœ¨é€£æ¥...</div>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">UP ç¸½è¨ˆ</div>
                <div class="stat-value up" id="totalUp">0.0000 BNB</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">DOWN ç¸½è¨ˆ</div>
                <div class="stat-value down" id="totalDown">0.0000 BNB</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ç¸½é‡‘é¡ (ä¸‹æ³¨æ•¸)</div>
                <div class="stat-value" id="totalBets">0.0000 BNB (0)</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">å±€æ¬¡ç‹€æ…‹</div>
                <div class="stat-value" id="roundStatus">--</div>
            </div>
        </div>

        <!-- å›æ¸¬æ•¸æ“šè¡¨æ ¼ -->
        <div class="backtest-section">
            <div class="backtest-header" id="backtestHeader">ğŸ“Š ç­–ç•¥å›æ¸¬è¡¨ç¾ï¼ˆç›¸äº’50æ ¼ï¼šç•¶å‰+å‰1å±€é æ¸¬ | 48å±€çµ±è¨ˆï¼‰</div>
            <div class="backtest-table-container">
                <table class="backtest-table" id="backtestTable">
                    <tbody>
                        <!-- è¡¨æ ¼å…§å®¹å°‡é€šé JavaScript å‹•æ…‹ç”Ÿæˆ -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="bets-container">
            <div class="bets-header">
                <div>æ™‚é–“</div>
                <div>å±€æ¬¡</div>
                <div>éŒ¢åŒ…åœ°å€</div>
                <div>æ–¹å‘</div>
                <div>é‡‘é¡ (BNB)</div>
                <div>åˆ†æ</div>
            </div>
            <div id="betsContent">
                <div class="no-data">ç­‰å¾…å³æ™‚ä¸‹æ³¨æ•¸æ“š...</div>
            </div>
        </div>
    </div>

    <div class="connection-status disconnected" id="connectionStatus">å·²æ–·ç·š</div>

    <script>
        'use strict';

        // ========================================
        // å·¥å…·å‡½æ•¸æ¨¡çµ„
        // ========================================
        
        const Utils = {
            /**
             * æ ¼å¼åŒ–æ™‚é–“
             */
            formatTime(timeString) {
                if (!timeString) return '--:--:--';
                const d = new Date(timeString);
                if (!isNaN(d.getTime())) {
                    return d.toLocaleTimeString('zh-TW', { 
                        timeZone: 'Asia/Taipei', 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit', 
                        hour12: false 
                    });
                }
                if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(timeString)) {
                    return timeString.split(' ')[1];
                }
                const m = timeString.match(/(\d{2}:\d{2}:\d{2})/);
                return m ? m[1] : timeString;
            },

            /**
             * æ ¼å¼åŒ–éŒ¢åŒ…åœ°å€ï¼ˆæ·»åŠ æ¨™ç±¤ï¼‰
             */
            formatWallet(address, walletTags) {
                if (!address) return '';
                let displayText = address;

                if (walletTags) {
                    if (walletTags.whale_level > 0) {
                        const whales = 'ğŸ³'.repeat(walletTags.whale_level);
                        displayText += `  ${whales}`;
                    }
                    if (walletTags.is_bot) {
                        displayText += '  ğŸ’»';
                    }
                }

                return displayText;
            },

            /**
             * ç²å–å¾—åˆ†é¡è‰²
             */
            getScoreColor(score) {
                if (score >= 80) return '#00FF00';
                if (score >= 60) return '#FFFF00';
                if (score >= 40) return '#FFA500';
                if (score >= 20) return '#FF6666';
                return '#FF0000';
            },

            /**
             * æ ¼å¼åŒ–å¾—åˆ†
             */
            formatScore(score) {
                return (score === null || score === undefined) ? '-' : `${score}%`;
            },

            /**
             * æ ¼å¼åŒ–ç›ˆè™§
             */
            formatProfitLoss(profitLoss) {
                if (profitLoss === null || profitLoss === undefined) return '-';
                const numValue = parseFloat(profitLoss);
                if (isNaN(numValue)) return '-';
                return numValue >= 0 ? `+${numValue.toFixed(3)}` : `${numValue.toFixed(3)}`;
            },

            /**
             * ç²å–ç›ˆè™§é¡è‰²
             */
            getProfitLossColor(profitLoss) {
                if (profitLoss === null || profitLoss === undefined) return '#666';
                const numValue = parseFloat(profitLoss);
                if (isNaN(numValue)) return '#666';
                return numValue > 0 ? '#28a745' : numValue < 0 ? '#dc3545' : '#666';
            }
        };

        // ========================================
        // WebSocket ç®¡ç†å™¨
        // ========================================

        class WebSocketManager {
            constructor(onConnect, onMessage, onDisconnect) {
                this.ws = null;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 3000;
                
                this.onConnect = onConnect;
                this.onMessage = onMessage;
                this.onDisconnect = onDisconnect;
            }

            connect() {
                try {
                    const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}`;
                    console.log('é€£æ¥ WebSocket:', wsUrl);
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket é€£æ¥æˆåŠŸ');
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.onConnect();
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.onMessage(data);
                        } catch (error) {
                            console.error('è§£ææ¶ˆæ¯å¤±æ•—:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket å·²æ–·é–‹');
                        this.isConnected = false;
                        this.onDisconnect();
                        this.scheduleReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket éŒ¯èª¤:', error);
                    };
                    
                } catch (error) {
                    console.error('é€£æ¥å¤±æ•—:', error);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * this.reconnectAttempts;
                    console.log(`${delay/1000}ç§’å¾Œé‡é€£...`);
                    setTimeout(() => {
                        if (!this.isConnected) this.connect();
                    }, delay);
                }
            }

            send(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    return true;
                }
                return false;
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
            }
        }

        // ========================================
        // ç‹€æ…‹ç®¡ç†å™¨
        // ========================================

        class StateManager {
            constructor() {
                this.currentRound = null;
                this.viewingEpoch = null;
                this.bets = [];
                this.stats = {
                    upTotal: 0,
                    downTotal: 0,
                    totalAmount: 0,
                    totalCount: 0,
                    bigBetsUp: 0,
                    bigBetsDown: 0
                };
                this.epochCache = new Map();
                this.maxCacheSize = 50;
            }

            setCurrentRound(roundData) {
                this.currentRound = roundData;
            }

            setViewingEpoch(epoch) {
                this.viewingEpoch = epoch;
            }

            setBets(bets) {
                this.bets = bets;
            }

            addBet(bet) {
                this.bets.unshift(bet);
                if (this.bets.length > 100) {
                    this.bets = this.bets.slice(0, 100);
                }
            }

            calculateStats() {
                this.stats = {
                    upTotal: 0,
                    downTotal: 0,
                    totalAmount: 0,
                    totalCount: this.bets.length,
                    bigBetsUp: 0,
                    bigBetsDown: 0
                };

                this.bets.forEach(bet => {
                    const amount = parseFloat(bet.amount || bet.bet_amount || 0);
                    this.stats.totalAmount += amount;
                    
                    if (bet.bet_direction === 'UP') {
                        this.stats.upTotal += amount;
                        if (amount >= 0.1) this.stats.bigBetsUp++;
                    } else {
                        this.stats.downTotal += amount;
                        if (amount >= 0.1) this.stats.bigBetsDown++;
                    }
                });
            }

            saveToCache(epoch, data) {
                const existing = this.epochCache.get(epoch) || {};
                this.epochCache.set(epoch, { ...existing, ...data });

                if (this.epochCache.size > this.maxCacheSize) {
                    const sortedKeys = Array.from(this.epochCache.keys()).sort((a, b) => a - b);
                    const toDelete = sortedKeys.slice(0, this.epochCache.size - this.maxCacheSize);
                    toDelete.forEach(key => this.epochCache.delete(key));
                }
            }

            getFromCache(epoch) {
                return this.epochCache.get(epoch);
            }
        }

        // ========================================
        // åœ–è¡¨æ¸²æŸ“å™¨
        // ========================================

        class ChartRenderer {
            constructor() {
                this.width = 420;
                this.height = 50;
                this.padding = { top: 5, right: 10, bottom: 5, left: 10 };
                this.maxAmount = 1.25;
                this.gap1 = 12;
                this.gap2 = 10;
                this.pointSpacing = 7;
            }

            generate(chartData) {
                if (!chartData || chartData.length === 0) {
                    return '<div style="color: #666; font-size: 11px; text-align: center;">ç„¡åœ–è¡¨æ•¸æ“š</div>';
                }

                const dataPoints = this.prepareData(chartData);
                return this.renderSVG(dataPoints);
            }

            prepareData(chartData) {
                const chartHeight = this.height - this.padding.top - this.padding.bottom;
                const yScale = (amount) => chartHeight - (amount / this.maxAmount * chartHeight * 0.8);

                const xPositions = this.calculateXPositions();

                return chartData.slice(0, 50).map((point, index) => ({
                    x: xPositions[index],
                    y: this.padding.top + yScale(point.amount),
                    y0: this.padding.top + yScale(0),
                    amount: point.amount,
                    result: point.result,
                    index: index
                }));
            }

            calculateXPositions() {
                const positions = [];
                let currentX = this.padding.left;

                // ç¬¬1å±€
                positions[0] = currentX;
                currentX += this.pointSpacing;

                // ç¬¬2å±€
                positions[1] = currentX;
                currentX += this.gap1;

                // ç¬¬3-50å±€
                for (let i = 2; i < 50; i++) {
                    positions[i] = currentX;
                    currentX += this.pointSpacing;
                    if ((i - 2) > 0 && (i - 2) % 12 === 11 && i < 49) {
                        currentX += this.gap2;
                    }
                }

                return positions;
            }

            renderSVG(dataPoints) {
                const pathSegments = [];
                let currentSegment = [];
                const markers = [];

                for (const point of dataPoints) {
                    const hasBet = point.amount > 0 || point.index < 2;

                    if (hasBet) {
                        currentSegment.push(`${point.x},${point.y}`);
                    } else {
                        if (currentSegment.length > 0) {
                            pathSegments.push(currentSegment);
                            currentSegment = [];
                        }
                    }

                    markers.push(this.createMarker(point));
                }

                if (currentSegment.length > 0) {
                    pathSegments.push(currentSegment);
                }

                const paths = pathSegments.map(segment => {
                    if (segment.length < 2) return '';
                    return `<path d="M${segment.join(' L')}" fill="none" stroke="#555" stroke-width="1"/>`;
                }).join('');

                return `
                    <svg width="${this.width}" height="${this.height}" viewBox="0 0 ${this.width} ${this.height}" xmlns="http://www.w3.org/2000/svg">
                        ${paths}
                        ${markers.join('')}
                    </svg>
                `;
            }

            createMarker(point) {
                const { x, y, y0, index, result } = point;
                const size = 3;

                if (index === 0) {
                    // Xç¬¦è™Ÿ
                    return `<g>
                        <line x1="${x-size}" y1="${y-size}" x2="${x+size}" y2="${y+size}" stroke="#FFD700" stroke-width="1.5"/>
                        <line x1="${x-size}" y1="${y+size}" x2="${x+size}" y2="${y-size}" stroke="#FFD700" stroke-width="1.5"/>
                    </g>`;
                } else if (index === 1) {
                    // ä¸‰è§’å½¢
                    return `<polygon points="${x},${y-size} ${x-size},${y+size} ${x+size},${y+size}" fill="none" stroke="#00BFFF" stroke-width="1.2"/>`;
                } else {
                    // åœ“åœˆ
                    if (result === 'WIN') {
                        return `<circle cx="${x}" cy="${y}" r="3.5" fill="#00FF00" stroke="none"/>`;
                    } else if (result === 'LOSS') {
                        return `<circle cx="${x}" cy="${y}" r="3.5" fill="#FF0000" stroke="none"/>`;
                    } else {
                        return `<circle cx="${x}" cy="${y0}" r="3" fill="none" stroke="#888" stroke-width="1"/>`;
                    }
                }
            }
        }

        // ========================================
        // ä¸‹æ³¨æ¸²æŸ“å™¨
        // ========================================

        class BetRenderer {
            constructor() {
                this.chartRenderer = new ChartRenderer();
            }

            generateBetHTML(bet, analysis, isNewBet = false) {
                const amount = parseFloat(bet.amount || bet.bet_amount || 0);
                const amountClass = this.getAmountClass(amount);
                const walletInfo = analysis[bet.wallet_address.toLowerCase()];
                
                let betItemClass = 'bet-item';
                if (isNewBet) betItemClass += ' new-bet';

                let walletClass = 'bet-wallet';
                let walletStatsHtml = '';

                if (walletInfo) {
                    walletClass += this.getWalletClass(walletInfo);
                    walletStatsHtml = this.generateWalletStatsHTML(walletInfo);
                }

                const walletTags = walletInfo ? walletInfo.wallet_tags : null;
                const chartData = walletInfo ? walletInfo.chart_data : null;
                const chartSVG = chartData ? this.chartRenderer.generate(chartData) : '';

                return `
                    <div class="${betItemClass}" 
                         data-epoch="${bet.epoch}" 
                         data-wallet="${bet.wallet_address}" 
                         data-wallet-lc="${bet.wallet_address.toLowerCase()}" 
                         data-tx-hash="${bet.tx_hash || bet.txHash || ''}">
                        <div class="bet-time">${Utils.formatTime(bet.bet_time || bet.bet_ts)}</div>
                        <div class="bet-epoch">${bet.epoch}</div>
                        <div class="${walletClass}" data-tx-hash="${bet.tx_hash || bet.txHash || ''}">
                            <div>${Utils.formatWallet(bet.wallet_address, walletTags)}</div>
                            ${walletStatsHtml}
                        </div>
                        <div class="bet-direction ${bet.bet_direction.toLowerCase()}">${bet.bet_direction}</div>
                        <div class="bet-amount ${amountClass}">${amount.toFixed(4)}</div>
                        <div class="wallet-analysis">${chartSVG}</div>
                    </div>
                `;
            }

            getAmountClass(amount) {
                if (amount >= 1) return 'huge';
                if (amount >= 0.1) return 'large';
                if (amount >= 0.05) return 'medium';
                return 'small';
            }

            getWalletClass(walletInfo) {
                if (walletInfo.is_multi_claim) {
                    return walletInfo.total_amount < 5 ? ' multi-claim-below-5' : ' multi-claim-above-5';
                }
                return '';
            }

            generateWalletStatsHTML(walletInfo) {
                if (!walletInfo.short_12_rounds && !walletInfo.mid_48_rounds) return '';

                const short12 = walletInfo.short_12_rounds;
                const mid48 = walletInfo.mid_48_rounds;

                let html = '';

                // è¿‘12å±€ï¼šåªè¦æœ‰æ•¸æ“šçµæ§‹å°±é¡¯ç¤ºï¼ˆå³ä½¿ total_bets = 0 ä¹Ÿé¡¯ç¤º "-"ï¼‰
                if (short12) {
                    html += `
                        <div style="font-size: 11px; margin-top: 2px; line-height: 1.2;">
                            <b>è¿‘12å±€:</b> å¾—åˆ†: <b style="color: ${Utils.getScoreColor(short12.score)};">${Utils.formatScore(short12.score)}</b> |
                            ç›ˆè™§: <b style="color: ${Utils.getProfitLossColor(short12.profit_loss)};">${Utils.formatProfitLoss(short12.profit_loss)}</b>
                        </div>
                    `;
                }

                // è¿‘48å±€ï¼šåªè¦æœ‰æ•¸æ“šçµæ§‹å°±é¡¯ç¤ºï¼ˆå³ä½¿ total_bets = 0 ä¹Ÿé¡¯ç¤º "-"ï¼‰
                if (mid48) {
                    html += `
                        <div style="font-size: 11px; margin-top: 1px; color: #aaa; line-height: 1.2;">
                            <b>è¿‘48å±€:</b> å¾—åˆ†: <span style="color: ${Utils.getScoreColor(mid48.score)};">${Utils.formatScore(mid48.score)}</span> |
                            ç›ˆè™§: <span style="color: ${Utils.getProfitLossColor(mid48.profit_loss)};">${Utils.formatProfitLoss(mid48.profit_loss)}</span>
                        </div>
                    `;
                }

                return html;
            }
        }

        // ========================================
        // é«˜äº®ç®¡ç†å™¨
        // ========================================

        class HighlightManager {
            constructor() {
                this.highlights = this.loadFromStorage();
                this.classMap = {1: 'hl-1', 2: 'hl-2', 3: 'hl-3', 4: 'hl-4', 5: 'hl-5', 6: 'hl-6'};
            }

            loadFromStorage() {
                try {
                    const raw = localStorage.getItem('walletHighlights');
                    if (!raw) return new Map();
                    const obj = JSON.parse(raw);
                    return new Map(Object.entries(obj));
                } catch (e) {
                    return new Map();
                }
            }

            saveToStorage() {
                try {
                    const obj = Object.fromEntries(this.highlights.entries());
                    localStorage.setItem('walletHighlights', JSON.stringify(obj));
                } catch (e) {
                    console.warn('ä¿å­˜é«˜äº®å¤±æ•—', e);
                }
            }

            toggle(walletAddress) {
                const key = walletAddress.toLowerCase();
                const current = this.highlights.get(key) || 0;
                const next = (current + 1) % 7;
                
                if (next === 0) {
                    this.highlights.delete(key);
                } else {
                    this.highlights.set(key, next);
                }
                
                this.saveToStorage();
                return next;
            }

            getLevel(walletAddress) {
                return this.highlights.get(walletAddress.toLowerCase()) || 0;
            }

            applyToElement(element, walletAddress) {
                const level = this.getLevel(walletAddress);
                
                // ç§»é™¤æ‰€æœ‰é«˜äº®é¡
                Object.values(this.classMap).forEach(cls => element.classList.remove(cls));
                
                // æ·»åŠ æ–°é«˜äº®
                if (level > 0) {
                    element.classList.add(this.classMap[level]);
                }
            }

            applyToAllElements(container) {
                if (!this.highlights || this.highlights.size === 0) return;
                
                for (const [wallet, level] of this.highlights.entries()) {
                    const elements = container.querySelectorAll(`.bet-item[data-wallet-lc="${wallet}"]`);
                    elements.forEach(el => {
                        if (level > 0) {
                            el.classList.add(this.classMap[level]);
                        }
                    });
                }
            }

            clearAll() {
                this.highlights.clear();
                this.saveToStorage();
            }
        }

        // ========================================
        // UI ç®¡ç†å™¨
        // ========================================

        class UIManager {
            constructor(elements) {
                this.elements = elements;
            }

            updateConnectionStatus(connected, text) {
                this.elements.connectionStatus.textContent = connected ? 'å·²é€£ç·š' : 'å·²æ–·ç·š';
                this.elements.connectionStatus.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
                this.elements.connectionInfo.textContent = text;
            }

            updateRoundInfo(epoch, mode) {
                this.elements.currentRound.textContent = epoch;
                this.elements.epochMode.textContent = mode;
            }

            updateStats(stats) {
                const upCounter = stats.bigBetsUp > 0 ? ` (+${stats.bigBetsUp})` : '';
                const downCounter = stats.bigBetsDown > 0 ? ` (+${stats.bigBetsDown})` : '';
                
                this.elements.totalUp.textContent = `${stats.upTotal.toFixed(4)} BNB${upCounter}`;
                this.elements.totalDown.textContent = `${stats.downTotal.toFixed(4)} BNB${downCounter}`;
                this.elements.totalBets.textContent = `${stats.totalAmount.toFixed(4)} BNB (${stats.totalCount})`;
            }

            updateRoundStatus(status) {
                this.elements.roundStatus.textContent = status;
            }

            updateRoundStatusHTML(html) {
                this.elements.roundStatus.innerHTML = html;
            }

            updateNavigationButtons(currentEpoch, maxEpoch) {
                this.elements.prevEpoch.disabled = (currentEpoch <= 1);
                this.elements.nextEpoch.disabled = (maxEpoch > 0 && currentEpoch >= maxEpoch);
            }

            clearBetsDisplay() {
                this.elements.betsContent.innerHTML = '<div class="no-data">è¼‰å…¥å±€æ¬¡æ•¸æ“šä¸­...</div>';
            }

            showNoBets() {
                this.elements.betsContent.innerHTML = '<div class="no-data">æš«ç„¡ä¸‹æ³¨æ•¸æ“š</div>';
            }
        }

        // ========================================
        // ä¸»æ‡‰ç”¨ç¨‹å¼é¡
        // ========================================

        class RealtimeBettingTerminal {
            constructor() {
                // åˆå§‹åŒ–ç®¡ç†å™¨
                this.state = new StateManager();
                this.highlightManager = new HighlightManager();
                this.betRenderer = new BetRenderer();
                
                // DOM å…ƒç´ 
                this.elements = {
                    connectionStatus: document.getElementById('connectionStatus'),
                    connectionInfo: document.getElementById('connectionInfo'),
                    currentRound: document.getElementById('currentRound'),
                    epochMode: document.getElementById('epochMode'),
                    lockCountdown: document.getElementById('lockCountdown'),
                    totalUp: document.getElementById('totalUp'),
                    totalDown: document.getElementById('totalDown'),
                    totalBets: document.getElementById('totalBets'),
                    roundStatus: document.getElementById('roundStatus'),
                    betsContent: document.getElementById('betsContent'),
                    prevEpoch: document.getElementById('prevEpoch'),
                    nextEpoch: document.getElementById('nextEpoch'),
                    followBestRate: document.getElementById('followBestRate'),
                    reverseLowRate: document.getElementById('reverseLowRate'),
                    momentumRate: document.getElementById('momentumRate'),
                    momentumPrediction: document.getElementById('momentumPrediction'),
                    predictionConfidence: document.getElementById('predictionConfidence'),
                    momentumReasons: document.getElementById('momentumReasons'),
                    momentumReasonsText: document.getElementById('momentumReasonsText'),
                    txP50: document.getElementById('txP50'),
                    txP90: document.getElementById('txP90'),
                    txDelta: document.getElementById('txDelta'),
                    backtestHeader: document.getElementById('backtestHeader'),
                };

                this.ui = new UIManager(this.elements);

                // WebSocket
                this.wsManager = new WebSocketManager(
                    () => this.onConnect(),
                    (data) => this.onMessage(data),
                    () => this.onDisconnect()
                );

                // è¨ˆæ™‚å™¨
                this.countdownInterval = null;

                // ç‹€æ…‹æ¨™èªŒ
                this.isQueryingRealbet = false;
                this.queryEpoch = null;
                this.forceJumpToNewRound = false;
                this.backtestTableRendered = false;
                this.lastBacktestEpoch = null; // è¿½è¹¤ä¸Šæ¬¡å›æ¸¬çš„å±€æ¬¡

                // é˜²æŠ–è¨ˆæ™‚å™¨
                this.repositionTimer = null;

                this.init();
            }

            init() {
                console.log('åˆå§‹åŒ–ç³»çµ±...');
                this.setupEventListeners();
                this.wsManager.connect();
            }

            setupEventListeners() {
                // å±€æ¬¡å°èˆª
                this.elements.prevEpoch.addEventListener('click', () => this.navigateEpoch(-1));
                this.elements.nextEpoch.addEventListener('click', () => this.navigateEpoch(1));

                // éŒ¢åŒ…é«˜äº®
                this.elements.betsContent.addEventListener('click', (e) => this.onBetsContentClick(e));

                // æ¸…é™¤é«˜äº®
                const lockTimeDiv = document.querySelector('.lock-time');
                if (lockTimeDiv) {
                    lockTimeDiv.addEventListener('click', () => this.clearAllHighlights());
                }

                // é é¢å¯è¦‹æ€§
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && !this.wsManager.isConnected) {
                        this.wsManager.connect();
                    }
                });
            }

            // ========================================
            // WebSocket äº‹ä»¶è™•ç†
            // ========================================

            onConnect() {
                this.ui.updateConnectionStatus(true, 'å·²é€£æ¥');
                this.wsManager.send({ type: 'get_current_round' });
                
                // ç«‹å³è«‹æ±‚å›æ¸¬æ•¸æ“š
                console.log('ğŸ”„ é€£æ¥å»ºç«‹ï¼Œç«‹å³è«‹æ±‚å›æ¸¬æ•¸æ“š');
                this.wsManager.send({ type: 'force_backtest_refresh' });
                
                // é ç´„ 3 ç§’å¾Œå†æ¬¡è«‹æ±‚å›æ¸¬æ•¸æ“šï¼ˆé˜²æ­¢ Redis é‚„æ²’æº–å‚™å¥½ï¼‰
                setTimeout(() => {
                    if (!this.backtestTableRendered) {
                        console.log('ğŸ”„ 3ç§’å¾Œä»æœªæ”¶åˆ°å›æ¸¬æ•¸æ“šï¼Œé‡æ–°è«‹æ±‚');
                        this.wsManager.send({ type: 'force_backtest_refresh' });
                    }
                }, 3000);
                
                // é ç´„ 6 ç§’å¾Œæœ€å¾Œä¸€æ¬¡è«‹æ±‚ï¼ˆç¢ºä¿é é¢åˆ·æ–°å¾Œèƒ½æ­£ç¢ºè¼‰å…¥ï¼‰
                setTimeout(() => {
                    if (!this.backtestTableRendered) {
                        console.log('ğŸ”„ 6ç§’å¾Œä»æœªæ”¶åˆ°å›æ¸¬æ•¸æ“šï¼Œæœ€å¾Œä¸€æ¬¡è«‹æ±‚');
                        this.wsManager.send({ type: 'force_backtest_refresh' });
                    }
                }, 6000);
            }

            onDisconnect() {
                this.ui.updateConnectionStatus(false, 'é€£æ¥ä¸­æ–·');
            }

            onMessage(data) {
                switch (data.type) {
                    case 'current_round':
                    case 'round_update':
                        this.handleRoundUpdate(data.data);
                        break;
                    case 'backtest_update':
                        console.log('ğŸ“Š æ”¶åˆ° backtest_update æ¶ˆæ¯:', data.data);
                        if (data.data && data.data.strategies) {
                            console.log('ç­–ç•¥æ•¸é‡:', Object.keys(data.data.strategies).length);
                            Object.keys(data.data.strategies).forEach(key => {
                                const strategy = data.data.strategies[key];
                                console.log(`ç­–ç•¥ ${key}:`, {
                                    name: strategy.name,
                                    winRate: strategy.winRate,
                                    historyLength: strategy.history ? strategy.history.length : 0,
                                    hasHistory: !!strategy.history
                                });
                                if (strategy.history && strategy.history.length > 0) {
                                    console.log(`  å‰3ç­†æ­·å²:`, strategy.history.slice(0, 3));
                                }
                            });
                        } else {
                            console.warn('âš ï¸ backtest_update æ•¸æ“šæ ¼å¼éŒ¯èª¤æˆ–ç„¡ strategies');
                        }
                        this.handleBacktestUpdate(data.data);
                        break;
                    case 'live_predictions':
                        this.handleLivePredictions(data.data);
                        break;
                    case 'tx_benchmark':
                        this.handleTxBenchmark(data.data);
                        break;
                    case 'realtime_bets':
                        this.handleBetsData(data.data, 'realtime');
                        break;
                    case 'historical_bets':
                        this.handleBetsData(data.data, 'historical');
                        break;
                    case 'historical_round':
                        this.handleHistoricalRound(data.data);
                        break;
                    case 'new_bet':
                        this.handleNewBet(data.data);
                        break;
                    case 'bet_analysis':
                        console.log(`ğŸ“¥ æ”¶åˆ° bet_analysis:`, data.data.wallet_address?.substring(0, 8), 'å®Œæ•´æ•¸æ“š:', data.data);
                        this.handleBetAnalysis(data.data);
                        break;
                    default:
                        console.warn('â“ æœªçŸ¥è¨Šæ¯é¡å‹:', data.type);
                }
            }

            // ========================================
            // å±€æ¬¡è™•ç†
            // ========================================

            handleRoundUpdate(roundData) {
                if (!roundData) return;

                const oldLiveEpoch = this.state.currentRound ? this.state.currentRound.epoch : null;
                const newEpoch = parseInt(roundData.epoch);
                const oldEpoch = oldLiveEpoch ? parseInt(oldLiveEpoch) : null;
                const viewingEpoch = this.state.viewingEpoch ? parseInt(this.state.viewingEpoch) : null;
                const amIWatchingLive = (viewingEpoch === oldEpoch);
                const isNewRoundStarting = (oldEpoch !== null && newEpoch !== oldEpoch);

                // é˜²æ­¢å±€æ¬¡å€’é€€ï¼šå¦‚æœæ–°å±€æ¬¡æ¯”ç•¶å‰å·²çŸ¥çš„æœ€å¤§å±€æ¬¡é‚„èˆŠï¼Œå‰‡æ‹’çµ•
                if (oldEpoch !== null && newEpoch < oldEpoch) {
                    console.log(`ğŸš« æ‹’çµ•å€’é€€ï¼šæ”¶åˆ°èˆŠå±€æ¬¡ ${newEpoch}ï¼ˆç•¶å‰æœ€æ–°: ${oldEpoch}ï¼‰`);
                    return;
                }

                // é˜²æ­¢åœ¨è§€çœ‹ live æ™‚å€’é€€
                if (amIWatchingLive && viewingEpoch !== null && newEpoch < viewingEpoch) {
                    console.log(`ğŸš« æ‹’çµ•å€’é€€ï¼šæ–°å±€æ¬¡ ${newEpoch} < ç•¶å‰è§€çœ‹ ${viewingEpoch}`);
                    return;
                }

                console.log(`ğŸ“¥ Round Update: epoch=${newEpoch}, oldEpoch=${oldEpoch}, viewingEpoch=${viewingEpoch}, isNew=${isNewRoundStarting}, watchingLive=${amIWatchingLive}`);

                // æ›´æ–° currentRound
                this.state.setCurrentRound(roundData);

                // æ±ºå®šæ˜¯å¦éœ€è¦è¼‰å…¥æ–°æ•¸æ“š
                let shouldLoadNewData = false;

                if (this.forceJumpToNewRound && amIWatchingLive) {
                    // åªæœ‰åœ¨è§€çœ‹ live æ™‚æ‰å…è¨±å¼·åˆ¶è·³è½‰
                    console.log('ğŸ”„ å¼·åˆ¶è·³è½‰åˆ°æ–°å›åˆ');
                    this.forceJumpToNewRound = false;
                    shouldLoadNewData = true;
                } else if (!viewingEpoch) {
                    console.log('ğŸ”„ é¦–æ¬¡è¼‰å…¥');
                    shouldLoadNewData = true;
                } else if (isNewRoundStarting && amIWatchingLive) {
                    console.log('ğŸ”„ æ–°å›åˆé–‹å§‹ï¼Œè‡ªå‹•è·³è½‰');
                    shouldLoadNewData = true;
                } else if (this.forceJumpToNewRound && !amIWatchingLive) {
                    // å¦‚æœåœ¨çœ‹æ­·å²å±€æ¬¡ï¼Œæ¸…é™¤å¼·åˆ¶è·³è½‰æ¨™è¨˜ä½†ä¸è·³è½‰
                    console.log('ğŸš« è§€çœ‹æ­·å²å±€æ¬¡ä¸­ï¼Œå¿½ç•¥è‡ªå‹•è·³è½‰');
                    this.forceJumpToNewRound = false;
                }

                if (shouldLoadNewData) {
                    this.loadEpochData(newEpoch);
                } else {
                    // åªæ›´æ–°ç‹€æ…‹ï¼Œä¸é‡æ–°è¼‰å…¥æ•¸æ“š
                    if (viewingEpoch === newEpoch) {
                        this.ui.updateRoundStatus(roundData.status);
                        // æ›´æ–°çµ±è¨ˆæ•¸æ“šï¼ˆå³ä½¿ä¸é‡æ–°è¼‰å…¥ä¸‹æ³¨æ•¸æ“šï¼‰
                        this.state.calculateStats();
                        this.ui.updateStats(this.state.stats);
                    }
                }

                this.startCountdown(roundData);
            }

            startCountdown(roundData) {
                if (this.countdownInterval) clearInterval(this.countdownInterval);

                // é‡ç½®å€’æ•¸çµæŸæ¨™è¨˜
                this.countdownFinished = false;

                this.countdownInterval = setInterval(() => {
                    // ä½¿ç”¨æœ€æ–°çš„ currentRound è€Œä¸æ˜¯å‚³å…¥çš„å¿«ç…§
                    const current = this.state.currentRound || roundData;
                    const now = Math.floor(Date.now() / 1000);
                    let timeLeft;

                    if (current.status === 'LIVE') {
                        timeLeft = current.lockTimestamp - now;
                    } else if (current.status === 'LOCKED') {
                        timeLeft = current.closeTimestamp - now;
                    } else {
                        this.elements.lockCountdown.textContent = '--';
                        return;
                    }

                    if (timeLeft > 0) {
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        this.elements.lockCountdown.textContent =
                            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        // é‡ç½®æ¨™è¨˜ï¼Œå…è¨±ä¸‹æ¬¡å€’æ•¸çµæŸæ™‚è§¸ç™¼
                        this.countdownFinished = false;
                        
                        // åœ¨é–å€‰å‰5ç§’ï¼Œåˆ·æ–°å›æ¸¬è¡¨æ ¼ç¬¬3æ ¼ï¼ˆé¡¯ç¤ºä¸‹ä¸€å±€é æ¸¬ï¼‰
                        if (timeLeft <= 5 && timeLeft > 0) {
                            this.updateBacktestTableColumn0();
                        }
                    } else {
                        this.elements.lockCountdown.textContent = '00:00';

                        // åªåœ¨ç¬¬ä¸€æ¬¡å€’æ•¸åˆ° 00:00 æ™‚è§¸ç™¼ï¼Œé¿å…é‡è¤‡è«‹æ±‚
                        if (!this.countdownFinished) {
                            this.countdownFinished = true;
                            console.log('â° å€’æ•¸çµæŸï¼Œè«‹æ±‚æœ€æ–°å›åˆ');
                            this.forceJumpToNewRound = true;
                            this.wsManager.send({ type: 'get_current_round' });
                        }
                    }
                }, 1000);
            }

            handleHistoricalRound(roundData) {
                if (!roundData) {
                    this.ui.updateRoundStatus('ç„¡è³‡æ–™');
                    return;
                }

                if (roundData.result) {
                    const resultText = roundData.result === 'UP' ? 'æ¼²' : 'è·Œ';
                    const price = parseFloat(roundData.closePrice).toFixed(4);
                    this.ui.updateRoundStatusHTML(
                        `<span class="bet-direction ${roundData.result.toLowerCase()}">${resultText}</span> @ ${price}`
                    );
                } else {
                    this.ui.updateRoundStatus('å·²çµæŸ');
                }

                if (this.countdownInterval) clearInterval(this.countdownInterval);
                this.elements.lockCountdown.textContent = '--';

                if (roundData.epoch) {
                    this.state.saveToCache(parseInt(roundData.epoch), { roundInfo: roundData });
                }
            }

            // ========================================
            // å›æ¸¬æ•¸æ“šè™•ç†
            // ========================================

            handleBacktestUpdate(data) {
                if (!data || !data.strategies) return;

                const followBest = data.strategies.follow_best;
                const reverseLow = data.strategies.reverse_low;
                const momentum = data.strategies.momentum;
                
                // æª¢æŸ¥å±€æ¬¡æ˜¯å¦è®ŠåŒ–
                const newEpoch = data.currentEpoch;
                const epochChanged = this.lastBacktestEpoch !== null && this.lastBacktestEpoch !== newEpoch;
                
                if (epochChanged) {
                    console.log(`ğŸ”„ å±€æ¬¡è®ŠåŒ–: ${this.lastBacktestEpoch} â†’ ${newEpoch}ï¼Œå¼·åˆ¶åˆ·æ–°è¡¨æ ¼`);
                    // é‡ç½®ç‹€æ…‹ï¼Œå¼·åˆ¶åˆ·æ–°
                    this.backtestTableRendered = false;
                }
                this.lastBacktestEpoch = newEpoch;

                if (followBest) {
                    const rate = parseFloat(followBest.winRate);
                    const color = rate >= 55 ? '#0f0' : rate >= 50 ? '#ff0' : '#f00';
                    this.elements.followBestRate.textContent = `${followBest.winRate}% (${followBest.wins}/${followBest.total})`;
                    this.elements.followBestRate.style.color = color;
                }

                if (reverseLow) {
                    const rate = parseFloat(reverseLow.winRate);
                    const color = rate >= 55 ? '#0f0' : rate >= 50 ? '#ff0' : '#f00';
                    this.elements.reverseLowRate.textContent = `${reverseLow.winRate}% (${reverseLow.wins}/${reverseLow.total})`;
                    this.elements.reverseLowRate.style.color = color;
                }

                if (momentum) {
                    const rate = parseFloat(momentum.winRate);
                    const color = rate >= 55 ? '#0f0' : rate >= 50 ? '#ff0' : '#f00';
                    this.elements.momentumRate.textContent = `${momentum.winRate}% (${momentum.wins}/${momentum.total})`;
                    this.elements.momentumRate.style.color = color;
                }

                // æ¸²æŸ”å›æ¸¬è¡¨æ ¼
                this.renderBacktestTable(data);
            }

            renderBacktestTable(backtestData) {
                console.log('ğŸ“Š renderBacktestTable è¢«å‘¼å«:', backtestData);
                
                // å„²å­˜æœ€æ–°çš„å›æ¸¬æ•¸æ“šï¼Œä¾› updateBacktestTableColumn0 ä½¿ç”¨
                this.latestBacktestData = backtestData;
                
                // æ›´æ–°è¡¨æ ¼headeré¡¯ç¤ºç•¶å‰å±€æ¬¡
                if (backtestData && backtestData.currentEpoch) {
                    const currentEpoch = backtestData.currentEpoch;
                    if (this.elements.backtestHeader) {
                        this.elements.backtestHeader.innerHTML = `ğŸ“Š ç­–ç•¥å›æ¸¬è¡¨ç¾ï¼ˆ50æ ¼æ™‚é–“è»¸ï¼‰<br><span style="font-size:12px;color:#888;">ç¬¬3æ ¼=ç•¶å‰å±€<span style="color:#FFD700">#${currentEpoch}</span> | ç¬¬4æ ¼=#${currentEpoch-1} | ç¬¬5æ ¼èµ·=æ­·å²æ•¸æ“š</span>`;
                    }
                }
                
                const table = document.getElementById('backtestTable');
                if (!table) {
                    console.error('âš ï¸ æ‰¾ä¸åˆ° backtestTable');
                    return;
                }

                const tbody = table.querySelector('tbody');
                if (!tbody) {
                    console.error('âš ï¸ æ‰¾ä¸åˆ° tbody');
                    return;
                }
                
                // æª¢æŸ¥æ•¸æ“šæœ‰æ•ˆæ€§
                if (!backtestData || !backtestData.strategies) {
                    console.warn('âš ï¸ å›æ¸¬æ•¸æ“šç„¡æ•ˆï¼Œä¸æ›´æ–°è¡¨æ ¼');
                    return;
                }
                
                // æª¢æŸ¥æ¯å€‹ç­–ç•¥çš„æ­·å²æ•¸æ“š
                const strategyValidation = {};
                Object.keys(backtestData.strategies).forEach(key => {
                    const strategy = backtestData.strategies[key];
                    const isValid = strategy && strategy.history && strategy.history.length > 0;
                    strategyValidation[key] = {
                        hasStrategy: !!strategy,
                        hasHistory: !!(strategy && strategy.history),
                        historyLength: (strategy && strategy.history) ? strategy.history.length : 0,
                        isValid
                    };
                });
                
                console.log('ç­–ç•¥æœ‰æ•ˆæ€§æª¢æŸ¥:', strategyValidation);
                
                const hasValidData = Object.values(strategyValidation).some(v => v.isValid);
                
                if (!hasValidData) {
                    console.warn('âš ï¸ æ²’æœ‰æœ‰æ•ˆçš„æ­·å²æ•¸æ“šï¼Œä¸æ›´æ–°è¡¨æ ¼');
                    
                    // å¦‚æœè¡¨æ ¼å·²ç¶“æ¸²æŸ“éæˆ–å·²æœ‰å…§å®¹ï¼Œçµ•å°ä¸è¦ç”¨ç„¡æ•ˆæ•¸æ“šè¦†è“‹
                    const currentRows = tbody.querySelectorAll('tr');
                    const hasExistingData = currentRows.length > 0;
                    
                    if (this.backtestTableRendered || hasExistingData) {
                        console.log('è¡¨æ ¼å·²æ¸²æŸ“æˆ–å·²æœ‰å…§å®¹ï¼Œä¿æŒç¾æœ‰å…§å®¹ï¼Œæ‹’çµ•ç„¡æ•ˆæ•¸æ“š');
                        return;
                    }
                    
                    // å¦‚æœæ˜¯å…¨æ–°çš„è¡¨æ ¼ï¼Œé‚„æ˜¯è¦é¡¯ç¤ºä¸€ä¸ªåŠ è¼‰ä¸­çš„ç‹€æ…‹
                    tbody.innerHTML = `
                        <tr>
                            <td class="strategy-name">åŠ è¼‰ä¸­...</td>
                            <td class="strategy-winrate">-</td>
                            ${Array.from({length: 50}, () => '<td class="epoch-result"><span class="no-prediction">-</span></td>').join('')}
                        </tr>
                    `;
                    return;
                }

                // æå–ç­–ç•¥æ•¸æ“š
                const strategies = [
                    { 
                        name: 'å‹•é‡ç­–ç•¥', 
                        key: 'momentum',
                        data: backtestData.strategies.momentum 
                    },
                    { 
                        name: 'è·Ÿéš¨æœ€é«˜å‹ç‡', 
                        key: 'follow_best',
                        data: backtestData.strategies.follow_best 
                    },
                    { 
                        name: 'åå‘æœ€ä½å‹ç‡', 
                        key: 'reverse_low',
                        data: backtestData.strategies.reverse_low 
                    }
                ];
                
                // èª¿è©¦ï¼šè¼¸å‡ºhistoryçš„å‰5å€‹å±€æ¬¡ç·¨è™Ÿ
                console.log('ğŸ” æª¢æŸ¥historyå±€æ¬¡å°æ‡‰:');
                strategies.forEach(strategy => {
                    if (strategy.data && strategy.data.history) {
                        const first5Epochs = strategy.data.history.slice(0, 5).map(h => h.epoch);
                        console.log(`  ${strategy.name}: history[0-4].epoch = [${first5Epochs.join(', ')}]`);
                        console.log(`  é æœŸ history[0].epoch = ${backtestData.currentEpoch}, å¯¦éš› = ${strategy.data.history[0]?.epoch}`);
                    }
                });

                // æ›´åš´æ ¼æª¢æŸ¥æ˜¯å¦å·²æœ‰æœ‰æ•ˆå…§å®¹
                const existingRows = tbody.querySelectorAll('tr');
                const hasRealData = Array.from(existingRows).some(row => {
                    // æª¢æŸ¥ç­–ç•¥åç¨±ä¸æ˜¯åŠ è¼‰ä¸­ç‹€æ…‹
                    const nameCell = row.querySelector('td.strategy-name');
                    if (nameCell && nameCell.textContent.includes('åŠ è¼‰ä¸­')) {
                        return false; // é€™æ˜¯åŠ è¼‰ä¸­ç‹€æ…‹ï¼Œä¸ç®—æœ‰æ•ˆå…§å®¹
                    }
                    
                    // æª¢æŸ¥æ˜¯å¦æœ‰é æ¸¬åœ“åœˆ
                    const cells = row.querySelectorAll('td.epoch-result');
                    return cells.length > 0 && Array.from(cells).some(cell => {
                        const circle = cell.querySelector('.prediction-circle');
                        return circle && (circle.classList.contains('prediction-up') || 
                                        circle.classList.contains('prediction-down') ||
                                        circle.style.background);
                    });
                });
                
                if ((hasRealData && this.backtestTableRendered) || (hasRealData && !hasValidData)) {
                    console.log('è¡¨æ ¼å·²æœ‰æœ‰æ•ˆå…§å®¹ä¸”æ–°æ•¸æ“šç„¡æ•ˆï¼Œæ‹’çµ•è¦†è“‹');
                    return;
                }
                
                // åªæœ‰åœ¨çœŸæ­£æœ‰æœ‰æ•ˆæ–°æ•¸æ“šæ™‚æ‰æ¸…ç©ºè¡¨æ ¼
                console.log('æ¸…ç©ºè¡¨æ ¼ä¸¦é–‹å§‹é‡æ–°æ¸²æŸ“ï¼ŒhasRealData:', hasRealData, 'hasValidData:', hasValidData);
                
                // æ¸…ç©ºç¾æœ‰å…§å®¹
                tbody.innerHTML = '';

                // ç‚ºæ¯å€‹ç­–ç•¥å‰µå»ºä¸€è¡Œ
                strategies.forEach(strategy => {
                    console.log(`æ¸²æŸ“ç­–ç•¥: ${strategy.name}`, strategy.data);
                    if (!strategy.data) {
                        console.warn(`ç­–ç•¥ ${strategy.name} ç„¡æ•¸æ“š`);
                        return;
                    }

                    const row = document.createElement('tr');
                    row.dataset.strategy = strategy.key;

                    // ç¬¬ä¸€åˆ—ï¼šç­–ç•¥åç¨±
                    const nameCell = document.createElement('td');
                    nameCell.className = 'strategy-name';
                    nameCell.textContent = strategy.name;
                    row.appendChild(nameCell);

                    // ç¬¬äºŒåˆ—ï¼šå‹ç‡
                    const winrateCell = document.createElement('td');
                    winrateCell.className = 'strategy-winrate';
                    const rate = parseFloat(strategy.data.winRate || 0);
                    const winrateClass = rate >= 55 ? 'winrate-high' : rate >= 50 ? 'winrate-medium' : 'winrate-low';
                    winrateCell.innerHTML = `<span class="${winrateClass}">${strategy.data.winRate}%</span><br><span style="font-size: 10px; color: #666;">${strategy.data.wins}/${strategy.data.total}</span>`;
                    row.appendChild(winrateCell);

                    // ç¸½å…±50åˆ—ï¼šç•¶å‰å±€(1) + å‰1å±€(1) + 48å±€çµ±è¨ˆ(48) = 50
                    const history = strategy.data.history || [];
                    console.log(`${strategy.name} history é•·åº¦:`, history.length);
                    
                    // æ¸²æŸ“50å€‹æ ¼å­ï¼Œå°æ‡‰å®Œæ•´çš„æ™‚é–“è»¸
                    for (let i = 0; i < 50; i++) {
                        const epochCell = document.createElement('td');
                        epochCell.className = 'epoch-result';
                        epochCell.dataset.epochIndex = i;

                        if (history[i]) {
                            const prediction = history[i].prediction; // 'UP' or 'DOWN'
                            const result = history[i].result; // 'UP' or 'DOWN' or null
                            const isWin = history[i].isWin; // true/false/null

                            // ç‰¹æ®Šè™•ç†ï¼šç¬¬3æ ¼ï¼ˆi=0ï¼‰æ˜¯ä¸‹ä¸€å±€é æ¸¬ï¼Œåªåœ¨é–å€‰å‰5ç§’æ‰é¡¯ç¤º
                            if (i === 0) {
                                // æª¢æŸ¥ç•¶å‰æ˜¯å¦åœ¨é–å€‰å‰5ç§’
                                const currentRound = this.state.currentRound;
                                const now = Math.floor(Date.now() / 1000);
                                const timeUntilLock = currentRound ? (currentRound.lockTimestamp - now) : 999999;
                                
                                if (timeUntilLock > 5 || timeUntilLock < 0) {
                                    // ä¸åœ¨æœ€å¾Œ5ç§’ï¼Œé¡¯ç¤ºå°é»
                                    epochCell.innerHTML = '<span class="no-prediction" style="color: #333; font-size: 8px;" title="ä¸‹ä¸€å±€é æ¸¬å°‡åœ¨é–å€‰å‰5ç§’é¡¯ç¤º">Â·</span>';
                                    row.appendChild(epochCell);
                                    continue; // è·³éå¾ŒçºŒè™•ç†
                                }
                                // åœ¨æœ€å¾Œ5ç§’ï¼Œç¹¼çºŒé¡¯ç¤ºé æ¸¬
                            }

                            // å‰µå»ºé æ¸¬åœ“åœˆ
                            const circle = document.createElement('div');
                            circle.className = 'prediction-circle';
                            
                            // æ ¹æ“šæ™‚é–“è»¸è¨­ç½®èƒŒæ™¯è‰²ï¼š
                            // i=0: ä¸‹ä¸€å±€é æ¸¬ï¼ˆé–å€‰å‰5ç§’æ‰é¡¯ç¤ºï¼‰ï¼Œæ°¸é ç„¡èƒŒæ™¯è‰²
                            // i=1: ç•¶å‰å±€é æ¸¬ï¼Œæ°¸é ç„¡èƒŒæ™¯è‰²ï¼ˆçµæœæœªå‡ºï¼‰  
                            // i>=2: æ­·å²å±€ï¼ˆ48å±€çµ±è¨ˆç¯„åœï¼‰ï¼Œæ‰é¡¯ç¤ºèƒŒæ™¯è‰²
                            let hasBackground = false;
                            if (i >= 2 && result) {
                                hasBackground = true;
                                if (result === 'UP') {
                                    epochCell.classList.add('result-bg-up');
                                } else if (result === 'DOWN') {
                                    epochCell.classList.add('result-bg-down');
                                }
                            }

                            // è¨­ç½®åœ“åœˆé¡è‰²ï¼šå¦‚æœé æ¸¬æ­£ç¢ºä¸”æœ‰èƒŒæ™¯è‰²ï¼Œä½¿ç”¨æ›´èåˆçš„é¡è‰²
                            if (prediction === 'UP') {
                                if (hasBackground && result === 'UP' && isWin) {
                                    // é æ¸¬æ­£ç¢ºï¼Œä½¿ç”¨èˆ‡èƒŒæ™¯æ›´èåˆçš„ç¶ è‰²
                                    circle.style.background = '#2d5a2d';
                                } else {
                                    circle.classList.add('prediction-up');
                                }
                            } else if (prediction === 'DOWN') {
                                if (hasBackground && result === 'DOWN' && isWin) {
                                    // é æ¸¬æ­£ç¢ºï¼Œä½¿ç”¨èˆ‡èƒŒæ™¯æ›´èåˆçš„ç´…è‰²
                                    circle.style.background = '#5a2d2d';
                                } else {
                                    circle.classList.add('prediction-down');
                                }
                            } else {
                                circle.classList.add('prediction-none');
                            }

                            epochCell.appendChild(circle);

                            // æ·»åŠ  tooltip é¡¯ç¤ºè©³æƒ…
                            let tooltipText = `å±€æ¬¡: ${history[i].epoch || 'N/A'}\né æ¸¬: ${prediction || 'N/A'}\nçµæœ: ${result || 'æœªçŸ¥'}`;
                            if (i === 0) {
                                tooltipText += '\n[ä¸‹ä¸€å±€é æ¸¬ - é–å€‰å‰5ç§’é¡¯ç¤º]';
                            } else if (i === 1) {
                                tooltipText += '\n[ç•¶å‰å±€é æ¸¬ - ç„¡èƒŒæ™¯è‰²]';
                            } else if (isWin !== null) {
                                tooltipText += `\n[æ­·å²å±€ - çµ±è¨ˆç¯„åœ] ${isWin ? 'âœ“ å‹' : 'âœ— æ•—'}`;
                            }
                            epochCell.title = tooltipText;
                        } else {
                            // ç„¡æ•¸æ“š
                            if (i === 0) {
                                // ç¬¬3æ ¼ï¼šä¸‹ä¸€å±€é æ¸¬ï¼Œå¤§éƒ¨åˆ†æ™‚é–“æ˜¯ç©ºçš„
                                epochCell.innerHTML = '<span class="no-prediction" style="color: #333; font-size: 8px;" title="ä¸‹ä¸€å±€é æ¸¬å°‡åœ¨é–å€‰å‰5ç§’é¡¯ç¤º">Â·</span>';
                            } else {
                                epochCell.innerHTML = '<span class="no-prediction">-</span>';
                            }
                        }

                        row.appendChild(epochCell);
                    }

                    tbody.appendChild(row);
                });

                console.log('ğŸ“Š å›æ¸¬è¡¨æ ¼å·²æ›´æ–°');
                this.backtestTableRendered = true;
            }
            
            // æ›´æ–°å›æ¸¬è¡¨æ ¼ç¬¬3æ ¼ï¼ˆi=0ï¼‰ï¼Œç”¨æ–¼åœ¨é–å€‰å‰5ç§’å‹•æ…‹é¡¯ç¤ºé æ¸¬
            updateBacktestTableColumn0() {
                const table = document.getElementById('backtestTable');
                if (!table) return;
                
                const tbody = table.querySelector('tbody');
                if (!tbody) return;
                
                // æª¢æŸ¥ç•¶å‰æ˜¯å¦åœ¨é–å€‰å‰5ç§’
                const currentRound = this.state.currentRound;
                if (!currentRound) return;
                
                const now = Math.floor(Date.now() / 1000);
                const timeUntilLock = currentRound.lockTimestamp - now;
                
                // åªåœ¨é–å€‰å‰5ç§’å…§è™•ç†
                if (timeUntilLock > 5 || timeUntilLock < 0) return;
                
                // æ›´æ–°æ‰€æœ‰ç­–ç•¥çš„ç¬¬3æ ¼ï¼ˆi=0ï¼‰
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    const firstEpochCell = row.querySelector('td.epoch-result[data-epoch-index="0"]');
                    if (!firstEpochCell) return;
                    
                    // å¦‚æœå·²ç¶“é¡¯ç¤ºäº†é æ¸¬åœ“åœˆï¼Œå°±ä¸ç”¨å†æ›´æ–°
                    if (firstEpochCell.querySelector('.prediction-circle')) return;
                    
                    // å¾è¡Œçš„ data-strategy å±¬æ€§å–å¾—ç­–ç•¥åç¨±
                    const strategyKey = row.dataset.strategy;
                    if (!strategyKey) return;
                    
                    // å¾æœ€æ–°çš„å›æ¸¬æ•¸æ“šä¸­å–å¾—é æ¸¬
                    // é€™è£¡éœ€è¦å¾WebSocketæ”¶åˆ°çš„æœ€æ–° backtest æ•¸æ“šä¸­è®€å–
                    // æˆ‘å€‘åœ¨ renderBacktestTable æ™‚å·²ç¶“å„²å­˜äº†é€™äº›æ•¸æ“š
                    if (!this.latestBacktestData || !this.latestBacktestData.strategies) return;
                    
                    const strategy = this.latestBacktestData.strategies[strategyKey];
                    if (!strategy || !strategy.history || !strategy.history[0]) return;
                    
                    const prediction = strategy.history[0].prediction;
                    if (!prediction) return;
                    
                    // å‰µå»ºé æ¸¬åœ“åœˆ
                    const circle = document.createElement('div');
                    circle.className = 'prediction-circle';
                    
                    if (prediction === 'UP') {
                        circle.classList.add('prediction-up');
                    } else if (prediction === 'DOWN') {
                        circle.classList.add('prediction-down');
                    }
                    
                    // æ¸…ç©ºåŸæœ‰å…§å®¹ä¸¦æ·»åŠ æ–°åœ“åœˆ
                    firstEpochCell.innerHTML = '';
                    firstEpochCell.appendChild(circle);
                    firstEpochCell.title = `ä¸‹ä¸€å±€é æ¸¬: ${prediction}\n[é–å€‰å‰5ç§’é¡¯ç¤º]`;
                });
            }

            // ========================================
            // å¯¦æ™‚é æ¸¬è™•ç†
            // ========================================

            handleLivePredictions(data) {
                if (!data || !data.strategies) return;
                
                console.log('ğŸ”® æ”¶åˆ°å¯¦æ™‚é æ¸¬:', data);

                // åªè™•ç†å‹•é‡ç­–ç•¥ï¼ˆæ•ˆèƒ½æœ€ä½³ï¼‰
                const momentum = data.strategies.momentum;
                if (momentum) {
                    // æ›´æ–°é æ¸¬çµæœ
                    this.elements.momentumPrediction.textContent = momentum.prediction;
                    this.elements.momentumPrediction.style.color = momentum.prediction === 'UP' ? '#4CAF50' : '#F44336';
                    
                    // æ›´æ–°ä¿¡å¿ƒåº¦æŒ‡æ¨™
                    let confidenceText = 'ä¸­ç­‰ä¿¡å¿ƒ';
                    let confidenceColor = '#666';
                    
                    if (momentum.confidence === 'high') {
                        confidenceText = 'é«˜ä¿¡å¿ƒ';
                        confidenceColor = '#4CAF50';
                    } else if (momentum.confidence === 'low') {
                        confidenceText = 'ä½ä¿¡å¿ƒ';
                        confidenceColor = '#ff9800';
                    }
                    
                    this.elements.predictionConfidence.textContent = confidenceText;
                    this.elements.predictionConfidence.style.color = confidenceColor;
                    
                    // æ›´æ–°ç†ç”±
                    if (momentum.reasons && momentum.reasons.length > 0) {
                        this.elements.momentumReasons.style.display = 'block';
                        this.elements.momentumReasonsText.textContent = momentum.reasons.join('ã€');
                    } else {
                        this.elements.momentumReasons.style.display = 'none';
                        this.elements.momentumReasonsText.textContent = '--';
                    }

                    console.log(`ğŸ¯ å‹•é‡é æ¸¬: ${momentum.prediction} (ä¿¡å¿ƒåº¦: ${momentum.confidence})`);
                }
            }

            handleTxBenchmark(data) {
                // ç´¯ç©è¿‘ 100 ç­†æ¨£æœ¬
                if (!this.txBenchmarks) this.txBenchmarks = [];
                this.txBenchmarks.push(data);
                if (this.txBenchmarks.length > 100) this.txBenchmarks.shift();

                const samples = this.txBenchmarks.filter(x => x && typeof x.total_ms === 'number').map(x => x.total_ms);
                if (samples.length === 0) return;
                samples.sort((a,b)=>a-b);
                const p50 = samples[Math.floor(samples.length * 0.5)] || samples[0];
                const p90 = samples[Math.floor(samples.length * 0.9)] || samples[samples.length-1];
                this.elements.txP50.textContent = p50;
                this.elements.txP90.textContent = p90;

                // å»ºè­° Î´ï¼šä»¥æˆåŠŸç‡ >= 90% çš„æœ€å° delta
                const byDelta = new Map();
                for (const x of this.txBenchmarks) {
                    if (!x || x.delta == null) continue;
                    const d = x.delta;
                    const s = byDelta.get(d) || { ok: 0, total: 0 };
                    s.total += 1; if (x.success) s.ok += 1;
                    byDelta.set(d, s);
                }
                let best = null;
                for (const [d, s] of Array.from(byDelta.entries()).sort((a,b)=>a[0]-b[0])) {
                    const rate = s.total ? (s.ok / s.total) : 0;
                    if (rate >= 0.9) { best = d; break; }
                }
                this.elements.txDelta.textContent = best != null ? best : '--';
            }

            // ========================================
            // ä¸‹æ³¨æ•¸æ“šè™•ç†
            // ========================================

            handleBetsData(betsData, source) {
                if (this.isQueryingRealbet && source === 'realtime') {
                    if (betsData.length === 0) {
                        this.isQueryingRealbet = false;
                        this.wsManager.send({ type: 'get_historical_bets', epoch: this.queryEpoch });
                        return;
                    } else {
                        this.isQueryingRealbet = false;
                    }
                }

                // å¼·åˆ¶éæ¿¾ï¼šåªæ¥å—ç•¶å‰è§€çœ‹å±€æ¬¡çš„æ•¸æ“š
                const currentViewingEpoch = parseInt(this.state.viewingEpoch);
                if (!currentViewingEpoch) {
                    console.warn('âš ï¸ viewingEpoch æœªè¨­å®šï¼Œå¿½ç•¥æ•¸æ“š');
                    return;
                }

                // åš´æ ¼éæ¿¾ï¼šåªä¿ç•™å®Œå…¨åŒ¹é…ç•¶å‰å±€æ¬¡çš„ä¸‹æ³¨
                const newBets = betsData.filter(bet => {
                    const betEpoch = parseInt(bet.epoch);
                    if (betEpoch !== currentViewingEpoch) {
                        console.log(`ğŸš« æ‹’çµ•ä¸åŒ¹é…çš„ä¸‹æ³¨: epoch ${betEpoch} (ç•¶å‰è§€çœ‹: ${currentViewingEpoch})`);
                        return false;
                    }
                    return true;
                });

                const existingKeys = new Set(this.state.bets.map(bet => this.getBetKey(bet)));
                const uniqueNewBets = newBets.filter(bet => !existingKeys.has(this.getBetKey(bet)));

                if (source === 'historical') {
                    this.state.setBets(newBets);
                } else {
                    this.state.setBets([...this.state.bets, ...uniqueNewBets]);
                }

                this.state.calculateStats();
                this.renderBets();

                if (this.state.viewingEpoch && this.state.bets.length > 0) {
                    this.state.saveToCache(parseInt(this.state.viewingEpoch), { bets: [...this.state.bets] });
                }
            }

            handleNewBet(betData) {
                if (!this.state.currentRound || !this.state.viewingEpoch) return;

                const betEpoch = parseInt(betData.epoch);
                const viewingEpoch = parseInt(this.state.viewingEpoch);
                const currentRoundEpoch = parseInt(this.state.currentRound.epoch);

                // æª¢æŸ¥æ˜¯å¦åœ¨æ­·å²æ¨¡å¼ï¼ˆè§€çœ‹èˆŠå±€æ¬¡ï¼‰
                const isHistoryMode = (viewingEpoch !== currentRoundEpoch);

                if (isHistoryMode) {
                    console.log(`ğŸš« æ­·å²æ¨¡å¼ä¸­ï¼Œå¿½ç•¥å³æ™‚ä¸‹æ³¨: epoch ${betEpoch}`);
                    return;
                }

                // å¦‚æœæ”¶åˆ°æ–°å±€æ¬¡çš„ä¸‹æ³¨ï¼Œè‡ªå‹•åˆ‡æ›åˆ°æ–°å±€æ¬¡
                if (betEpoch !== viewingEpoch) {
                    if (betEpoch > viewingEpoch) {
                        console.log(`ğŸ”„ æ”¶åˆ°æ–°å±€æ¬¡ä¸‹æ³¨ (${betEpoch})ï¼Œè‡ªå‹•åˆ‡æ›ï¼`);
                        this.loadEpochData(betEpoch);
                        return;
                    } else {
                        console.log(`ğŸš« æ‹’çµ•èˆŠå±€æ¬¡ä¸‹æ³¨: epoch ${betEpoch} (ç•¶å‰è§€çœ‹: ${viewingEpoch})`);
                        return;
                    }
                }

                const betKey = this.getBetKey(betData);
                const existingBet = this.state.bets.find(bet => this.getBetKey(bet) === betKey);

                if (existingBet) return;

                this.state.addBet(betData);
                this.state.calculateStats();

                // ä½¿ç”¨å¹³æ»‘æ’å…¥æ–¹å¼ï¼Œä¸è§¸ç™¼æ•´å€‹åˆ—è¡¨é‡æ’
                this.insertNewBetSmoothly(betData);

                if (this.state.viewingEpoch) {
                    this.state.saveToCache(parseInt(this.state.viewingEpoch), { bets: [...this.state.bets] });
                }
            }

            handleBetAnalysis(analysisData) {
                console.log('ğŸ” handleBetAnalysis è¢«èª¿ç”¨ï¼Œåƒæ•¸:', analysisData);

                // æª¢æŸ¥æ˜¯å¦å±¬æ–¼ç•¶å‰è§€çœ‹çš„å±€æ¬¡
                const currentViewingEpoch = parseInt(this.state.viewingEpoch);
                console.log('  ç•¶å‰è§€çœ‹å±€æ¬¡:', currentViewingEpoch);

                if (!currentViewingEpoch) {
                    console.log('âš ï¸ ç„¡æ³•æ›´æ–°åˆ†æï¼šviewingEpoch æœªè¨­å®š');
                    return;
                }

                // æ›´æ–° state.bets ä¸­çš„åˆ†ææ•¸æ“š
                const walletAddress = analysisData.wallet_address?.toLowerCase();
                console.log('  éŒ¢åŒ…åœ°å€:', walletAddress);

                if (!walletAddress) {
                    console.log('âš ï¸ ç„¡æ³•æ›´æ–°åˆ†æï¼šwallet_address ç„¡æ•ˆ');
                    return;
                }

                console.log(`  ç•¶å‰ state.bets æ•¸é‡: ${this.state.bets.length}`);

                let updated = false;
                this.state.bets.forEach((bet, index) => {
                    if (bet.wallet_address.toLowerCase() === walletAddress) {
                        console.log(`  âœ“ æ‰¾åˆ°åŒ¹é…çš„ä¸‹æ³¨ [${index}]`);
                        this.state.bets[index].analysis = analysisData.analysis;
                        updated = true;
                    }
                });

                if (!updated) {
                    console.log(`âš ï¸ æ‰¾ä¸åˆ°å°æ‡‰çš„ä¸‹æ³¨è¨˜éŒ„: ${walletAddress.substring(0, 8)}...`);
                    console.log('  ç¾æœ‰éŒ¢åŒ…:', this.state.bets.map(b => b.wallet_address.substring(0, 8)).join(', '));
                    return;
                }

                // ç«‹å³æ›´æ–° DOM ä¸­å°æ‡‰çš„é …ç›®
                console.log(`ğŸ“Š æ”¶åˆ°ä¸¦æ›´æ–°åˆ†æ: ${walletAddress.substring(0, 8)}... (12å±€å¾—åˆ†: ${analysisData.analysis?.short_12_rounds?.score || '-'}%)`);

                // å…ˆæ›´æ–°å…§å®¹
                this.updateBetAnalysisInDOM(walletAddress, analysisData.analysis);

                // ä½¿ç”¨é˜²æŠ–é‡æ–°æ’åºï¼ˆ500ms å¾Œï¼‰ï¼Œé¿å…é »ç¹é‡æ’
                this.scheduleReposition();
            }

            updateBetAnalysisInDOM(walletAddress, analysisData) {
                const walletKey = walletAddress.toLowerCase();
                const items = this.elements.betsContent.querySelectorAll(`.bet-item[data-wallet-lc="${walletKey}"]`);

                if (items.length === 0) return;

                items.forEach((item) => {
                    const walletDiv = item.querySelector('.bet-wallet');
                    const analysisDiv = item.querySelector('.wallet-analysis');

                    if (!walletDiv || !analysisDiv) return;

                    const originalAddress = item.dataset.wallet;
                    const short12 = analysisData.short_12_rounds;
                    const mid48 = analysisData.mid_48_rounds;
                    const walletTags = analysisData.wallet_tags;

                    let statsHTML = '';
                    if (short12) {
                        statsHTML += `
                            <div style="font-size: 11px; margin-top: 2px; line-height: 1.2;">
                                <b>è¿‘12å±€:</b> å¾—åˆ†: <b style="color: ${Utils.getScoreColor(short12.score)};">${Utils.formatScore(short12.score)}</b> |
                                ç›ˆè™§: <b style="color: ${Utils.getProfitLossColor(short12.profit_loss)};">${Utils.formatProfitLoss(short12.profit_loss)}</b>
                            </div>
                        `;
                    }
                    if (mid48) {
                        statsHTML += `
                            <div style="font-size: 11px; margin-top: 1px; color: #aaa; line-height: 1.2;">
                                <b>è¿‘48å±€:</b> å¾—åˆ†: <span style="color: ${Utils.getScoreColor(mid48.score)};">${Utils.formatScore(mid48.score)}</span> |
                                ç›ˆè™§: <span style="color: ${Utils.getProfitLossColor(mid48.profit_loss)};">${Utils.formatProfitLoss(mid48.profit_loss)}</span>
                            </div>
                        `;
                    }

                    // ç›´æ¥æ›´æ–°ï¼Œä¸è¦æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                    walletDiv.innerHTML = `
                        <div>${Utils.formatWallet(originalAddress, walletTags)}</div>
                        ${statsHTML}
                    `;

                    if (analysisData.chart_data) {
                        const chartSVG = this.betRenderer.chartRenderer.generate(analysisData.chart_data);
                        analysisDiv.innerHTML = chartSVG;
                    }
                });
            }

            getBetKey(bet) {
                const txHash = bet.tx_hash || bet.txHash || '';
                return txHash || `${bet.wallet_address}-${bet.epoch}-${bet.bet_time || bet.bet_ts}-${bet.amount || bet.bet_amount}`;
            }

            // ========================================
            // æ¸²æŸ“é‚è¼¯
            // ========================================

            renderBets() {
                // äºŒæ¬¡éæ¿¾ï¼šç¢ºä¿ state.bets ä¸­åªæœ‰ç•¶å‰å±€æ¬¡çš„æ•¸æ“š
                const currentViewingEpoch = parseInt(this.state.viewingEpoch);
                if (currentViewingEpoch) {
                    const filteredBets = this.state.bets.filter(bet => {
                        const betEpoch = parseInt(bet.epoch);
                        if (betEpoch !== currentViewingEpoch) {
                            console.warn(`âš ï¸ æ¸²æŸ“æ™‚ç™¼ç¾ä¸åŒ¹é…çš„ä¸‹æ³¨: epoch ${betEpoch} (æ‡‰ç‚º: ${currentViewingEpoch})ï¼Œå·²ç§»é™¤`);
                            return false;
                        }
                        return true;
                    });
                    if (filteredBets.length !== this.state.bets.length) {
                        this.state.setBets(filteredBets);
                        this.state.calculateStats();
                    }
                }

                if (this.state.bets.length === 0) {
                    this.ui.showNoBets();
                    return;
                }

                const existingNodes = new Map();
                this.elements.betsContent.querySelectorAll('.bet-item').forEach(node => {
                    const txHash = node.dataset.txHash;
                    if (txHash) existingNodes.set(txHash, node);
                });

                const analysis = this.buildAnalysisMap();
                const sortedBets = this.sortBets(analysis);

                const newNodes = [];
                const tempDiv = document.createElement('div');
                let lastHadScore = null;
                let separatorInserted = false;

                sortedBets.forEach((bet, index) => {
                    const txHash = bet.tx_hash || bet.txHash || '';
                    const scores = this.getScores(analysis[bet.wallet_address.toLowerCase()]);
                    const hasScore = scores.short12 !== null;

                    // æª¢æ¸¬äº¤ç•Œè™•ï¼šå¾æœ‰å¾—åˆ†è®Šæˆç„¡å¾—åˆ†
                    if (!separatorInserted && lastHadScore === true && hasScore === false) {
                        const separator = document.createElement('div');
                        separator.className = 'score-separator';
                        newNodes.push(separator);
                        separatorInserted = true;
                    }

                    lastHadScore = hasScore;

                    if (existingNodes.has(txHash)) {
                        newNodes.push(existingNodes.get(txHash));
                        existingNodes.delete(txHash);
                    } else {
                        const html = this.betRenderer.generateBetHTML(bet, analysis, false);
                        tempDiv.innerHTML = html;
                        const newNode = tempDiv.firstElementChild;
                        if (newNode) {
                            newNode.classList.add('fade-in');
                        }
                        newNodes.push(newNode);
                    }
                });

                this.elements.betsContent.replaceChildren(...newNodes);

                this.highlightManager.applyToAllElements(this.elements.betsContent);
                this.ui.updateStats(this.state.stats);
            }

            buildAnalysisMap() {
                const analysis = {};
                this.state.bets.forEach(bet => {
                    if (bet.analysis) {
                        analysis[bet.wallet_address.toLowerCase()] = bet.analysis;
                    }
                });
                console.log(`ğŸ“‹ åˆ†æåœ°åœ–ï¼šå…± ${Object.keys(analysis).length} å€‹éŒ¢åŒ…æœ‰åˆ†ææ•¸æ“š`);
                return analysis;
            }

            sortBets(analysis) {
                const sorted = [...this.state.bets].sort((a, b) => {
                    const aScores = this.getScores(analysis[a.wallet_address.toLowerCase()]);
                    const bScores = this.getScores(analysis[b.wallet_address.toLowerCase()]);

                    // ç„¡æ•¸æ“šçš„æ’åœ¨æœ€å¾Œ
                    const aHasData = aScores.short12 !== null;
                    const bHasData = bScores.short12 !== null;

                    if (!aHasData && !bHasData) return 0;
                    if (!aHasData) return 1;  // a ç„¡æ•¸æ“šï¼Œæ’å¾Œé¢
                    if (!bHasData) return -1; // b ç„¡æ•¸æ“šï¼Œæ’å¾Œé¢

                    // éƒ½æœ‰æ•¸æ“šï¼šå„ªå…ˆæ¯”è¼ƒ12å±€å‹ç‡ï¼ˆé«˜çš„åœ¨ä¸Š = b-a é™åºï¼‰
                    if (aScores.short12 !== bScores.short12) {
                        return bScores.short12 - aScores.short12; // bå¤§æ™‚è¿”å›æ­£æ•¸ï¼Œaæ’å¾Œé¢ = å¤§åœ¨å‰
                    }

                    // 12å±€å‹ç‡ç›¸åŒï¼Œæ¯”è¼ƒ48å±€å‹ç‡ï¼ˆé«˜çš„åœ¨ä¸Š = b-a é™åºï¼‰
                    const aHas48 = aScores.mid48 !== null;
                    const bHas48 = bScores.mid48 !== null;

                    if (!aHas48 && !bHas48) return 0;
                    if (!aHas48) return 1;  // a ç„¡48å±€æ•¸æ“šï¼Œæ’å¾Œé¢
                    if (!bHas48) return -1; // b ç„¡48å±€æ•¸æ“šï¼Œæ’å¾Œé¢

                    if (aScores.mid48 !== bScores.mid48) {
                        return bScores.mid48 - aScores.mid48; // bå¤§æ™‚è¿”å›æ­£æ•¸ï¼Œaæ’å¾Œé¢ = å¤§åœ¨å‰
                    }

                    // å‹ç‡å®Œå…¨ç›¸åŒï¼ŒæŒ‰ä¸‹æ³¨æ™‚é–“é™åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
                    const aTime = new Date(a.bet_time || a.bet_ts).getTime();
                    const bTime = new Date(b.bet_time || b.bet_ts).getTime();
                    return bTime - aTime;
                });

                // èª¿è©¦æ—¥èªŒï¼šé¡¯ç¤ºå‰5ç­†çš„æ’åºçµæœ
                console.log('ğŸ“Š æ’åºçµæœï¼ˆå‰5ç­†ï¼‰:');
                sorted.slice(0, 5).forEach((bet, idx) => {
                    const scores = this.getScores(analysis[bet.wallet_address.toLowerCase()]);
                    console.log(`  ${idx + 1}. ${bet.wallet_address.substring(0, 8)}... - 12å±€: ${scores.short12 ?? '-'}%, 48å±€: ${scores.mid48 ?? '-'}%`);
                });

                return sorted;
            }

            getScores(analysisData) {
                let short12 = null;
                let mid48 = null;

                if (analysisData && analysisData.short_12_rounds && analysisData.short_12_rounds.total_bets > 0) {
                    short12 = analysisData.short_12_rounds.score;
                }
                if (analysisData && analysisData.mid_48_rounds && analysisData.mid_48_rounds.total_bets > 0) {
                    mid48 = analysisData.mid_48_rounds.score;
                }

                return { short12, mid48 };
            }

            insertNewBetSmoothly(betData) {
                const analysis = this.buildAnalysisMap();
                const newBetHTML = this.betRenderer.generateBetHTML(betData, analysis, true);
                const betsContainer = this.elements.betsContent;

                if (betsContainer.innerHTML.includes('no-data') || betsContainer.children.length === 0) {
                    betsContainer.innerHTML = newBetHTML;
                    const newItem = betsContainer.firstElementChild;
                    if (newItem) {
                        this.highlightManager.applyToElement(newItem, betData.wallet_address);
                    }
                } else {
                    // æ‰¾åˆ°åˆ†éš”ç·šä½ç½®
                    const separator = betsContainer.querySelector('.score-separator');

                    if (separator) {
                        // æ’å…¥åˆ°åˆ†éš”ç·šä¹‹å¾Œï¼ˆç„¡æ•¸æ“šå€ï¼‰
                        separator.insertAdjacentHTML('afterend', newBetHTML);
                    } else {
                        // æ²’æœ‰åˆ†éš”ç·šï¼Œæ’å…¥åˆ°æœ€åº•éƒ¨
                        betsContainer.insertAdjacentHTML('beforeend', newBetHTML);
                    }

                    // æ‰¾åˆ°å‰›æ’å…¥çš„é …ç›®
                    const allItems = betsContainer.querySelectorAll('.bet-item');
                    const newItem = Array.from(allItems).find(item =>
                        item.dataset.wallet === betData.wallet_address &&
                        item.dataset.txHash === (betData.tx_hash || betData.txHash)
                    );

                    if (newItem) {
                        newItem.classList.add('fade-in');
                        newItem.style.opacity = '0';
                        newItem.style.transform = 'translateY(10px)';

                        // å¾åº•éƒ¨æ»‘å…¥ä¸¦æ·¡å…¥
                        setTimeout(() => {
                            newItem.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
                            newItem.style.opacity = '1';
                            newItem.style.transform = 'translateY(0)';

                            // æ¸…ç†æ¨£å¼
                            setTimeout(() => {
                                newItem.style.transition = '';
                                newItem.style.transform = '';
                            }, 400);
                        }, 50);

                        this.highlightManager.applyToElement(newItem, betData.wallet_address);
                    }

                    // é™åˆ¶é¡¯ç¤ºæ•¸é‡
                    const betItems = betsContainer.querySelectorAll('.bet-item');
                    if (betItems.length > 100) {
                        for (let i = 100; i < betItems.length; i++) {
                            betItems[i].style.transition = 'opacity 0.3s ease-in-out';
                            betItems[i].style.opacity = '0';
                            setTimeout(() => {
                                if (betItems[i].parentNode) {
                                    betItems[i].remove();
                                }
                            }, 300);
                        }
                    }
                }

                this.ui.updateStats(this.state.stats);
            }

            scheduleReposition() {
                // é˜²æŠ–ï¼š800ms å…§å¤šæ¬¡èª¿ç”¨åªåŸ·è¡Œæœ€å¾Œä¸€æ¬¡ï¼ˆå»¶é•·æ™‚é–“è®“æ•¸æ“šéƒ½åˆ°é½Šï¼‰
                if (this.repositionTimer) {
                    clearTimeout(this.repositionTimer);
                }

                this.repositionTimer = setTimeout(() => {
                    this.repositionBetsWithAnimation();
                    this.repositionTimer = null;
                }, 800);
            }

            repositionBetsWithAnimation() {
                console.log('ğŸ”„ é–‹å§‹é‡æ–°æ’åº...');
                const analysis = this.buildAnalysisMap();
                const sortedBets = this.sortBets(analysis);

                // ä½¿ç”¨ getBetKey ä½œç‚ºå”¯ä¸€æ¨™è­˜ï¼ˆæ›´å¯é ï¼‰
                const currentPositions = new Map();
                this.elements.betsContent.querySelectorAll('.bet-item').forEach(item => {
                    const wallet = item.dataset.walletLc;
                    const epoch = item.dataset.epoch;
                    if (wallet && epoch) {
                        const key = `${wallet}-${epoch}`;
                        currentPositions.set(key, {
                            top: item.getBoundingClientRect().top,
                            element: item
                        });
                    }
                });

                // å»ºç«‹ç¾æœ‰ç¯€é»æ˜ å°„
                const existingNodes = new Map();
                this.elements.betsContent.querySelectorAll('.bet-item').forEach(node => {
                    const wallet = node.dataset.walletLc;
                    const epoch = node.dataset.epoch;
                    if (wallet && epoch) {
                        const key = `${wallet}-${epoch}`;
                        existingNodes.set(key, node);
                    }
                });

                const newNodes = [];
                let lastHadScore = null;
                let separatorInserted = false;

                sortedBets.forEach((bet) => {
                    const wallet = bet.wallet_address.toLowerCase();
                    const epoch = bet.epoch;
                    const key = `${wallet}-${epoch}`;

                    const scores = this.getScores(analysis[wallet]);
                    const hasScore = scores.short12 !== null;

                    // æ’å…¥åˆ†éš”ç·š
                    if (!separatorInserted && lastHadScore === true && hasScore === false) {
                        const separator = document.createElement('div');
                        separator.className = 'score-separator';
                        newNodes.push(separator);
                        separatorInserted = true;
                    }

                    lastHadScore = hasScore;

                    // æ·»åŠ å°æ‡‰çš„ç¯€é»
                    if (existingNodes.has(key)) {
                        newNodes.push(existingNodes.get(key));
                        existingNodes.delete(key);
                    }
                });

                console.log(`ğŸ“Š æ’åºå®Œæˆï¼šå…± ${newNodes.length} å€‹é …ç›®`);

                // å¹³æ»‘ç§»å‹•å‹•ç•«
                this.elements.betsContent.replaceChildren(...newNodes);

                // è¨ˆç®—æ–°ä½ç½®ä¸¦æ·»åŠ å‹•ç•«
                newNodes.forEach(node => {
                    if (node.classList && node.classList.contains('bet-item')) {
                        const wallet = node.dataset.walletLc;
                        const epoch = node.dataset.epoch;
                        if (wallet && epoch) {
                            const key = `${wallet}-${epoch}`;
                            if (currentPositions.has(key)) {
                                const oldTop = currentPositions.get(key).top;
                                const newTop = node.getBoundingClientRect().top;
                                const delta = oldTop - newTop;

                                if (Math.abs(delta) > 1) {
                                    // å…ˆç§»å‹•åˆ°èˆŠä½ç½®
                                    node.style.transform = `translateY(${delta}px)`;
                                    node.style.transition = 'none';

                                    // å¼·åˆ¶é‡ç¹ª
                                    node.offsetHeight;

                                    // å¹³æ»‘ç§»å‹•åˆ°æ–°ä½ç½®ï¼ˆä½¿ç”¨ ease-in-out æ›´æŸ”å’Œï¼‰
                                    node.style.transition = 'transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1)';
                                    node.style.transform = 'translateY(0)';

                                    // æ¸…ç†
                                    setTimeout(() => {
                                        node.style.transition = '';
                                        node.style.transform = '';
                                    }, 500);
                                }
                            }
                        }
                    }
                });

                this.highlightManager.applyToAllElements(this.elements.betsContent);
            }

            // ========================================
            // å±€æ¬¡å°èˆª
            // ========================================

            loadEpochData(epoch) {
                epoch = parseInt(epoch);
                this.state.setViewingEpoch(epoch);

                const isHistory = (this.state.currentRound &&
                                  parseInt(epoch) !== parseInt(this.state.currentRound.epoch));

                this.ui.updateRoundInfo(epoch, isHistory ? 'æ­·å²æ¨¡å¼' : 'å³æ™‚æ¨¡å¼');

                // æ¸…ç©ºç•¶å‰æ•¸æ“šï¼Œé¿å…é¡¯ç¤ºå‰ä¸€å±€çš„æ•¸æ“š
                this.state.setBets([]);
                this.state.calculateStats();
                this.ui.updateStats(this.state.stats);

                const cached = this.state.getFromCache(epoch);
                if (cached && cached.bets && cached.bets.length > 0) {
                    console.log(`ä½¿ç”¨ç·©å­˜: epoch ${epoch} (${cached.bets.length} ç­†)`);
                    this.state.setBets(cached.bets);
                    this.state.calculateStats();
                    this.renderBets();

                    if (isHistory && cached.roundInfo) {
                        this.handleHistoricalRound(cached.roundInfo);
                    }

                    this.ui.updateNavigationButtons(epoch,
                        this.state.currentRound ? parseInt(this.state.currentRound.epoch) : 0);
                    return;
                }

                console.log(`è¼‰å…¥ epoch ${epoch}`);
                this.ui.clearBetsDisplay();

                this.isQueryingRealbet = true;
                this.queryEpoch = epoch;
                this.wsManager.send({ type: 'get_realtime_bets', epoch: epoch });

                if (isHistory) {
                    this.wsManager.send({ type: 'get_historical_round', epoch: epoch });
                }

                this.ui.updateNavigationButtons(epoch,
                    this.state.currentRound ? parseInt(this.state.currentRound.epoch) : 0);
            }

            navigateEpoch(direction) {
                if (!this.state.currentRound) return;
                const currentEpoch = parseInt(this.state.viewingEpoch) || 0;
                const targetEpoch = currentEpoch + direction;
                if (targetEpoch < 1) return;
                this.loadEpochData(targetEpoch);
            }

            // ========================================
            // é«˜äº®ç®¡ç†
            // ========================================

            onBetsContentClick(e) {
                const walletEl = e.target.closest('.bet-wallet');
                if (!walletEl) return;
                
                const itemEl = walletEl.closest('.bet-item');
                const wallet = itemEl?.dataset.wallet;
                if (!wallet) return;

                this.highlightManager.toggle(wallet);
                this.applyHighlightForWallet(wallet);
            }

            applyHighlightForWallet(walletAddress) {
                const key = walletAddress.toLowerCase();
                const rows = this.elements.betsContent.querySelectorAll(`.bet-item[data-wallet-lc="${key}"]`);
                rows.forEach(row => {
                    this.highlightManager.applyToElement(row, walletAddress);
                });
            }

            clearAllHighlights() {
                const allBetItems = this.elements.betsContent.querySelectorAll('.bet-item');
                allBetItems.forEach(item => {
                    Object.values(this.highlightManager.classMap).forEach(cls => {
                        item.classList.remove(cls);
                    });
                });

                this.highlightManager.clearAll();
                console.log('å·²æ¸…é™¤æ‰€æœ‰é«˜äº®');
            }
        }

        // ========================================
        // å•Ÿå‹•æ‡‰ç”¨
        // ========================================

        document.addEventListener('DOMContentLoaded', () => {
            window.app = new RealtimeBettingTerminal();
        });

        window.addEventListener('error', (event) => {
            console.error('é é¢éŒ¯èª¤:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('æœªè™•ç†çš„ Promise æ‹’çµ•:', event.reason);
        });
    </script>
</body>
</html>